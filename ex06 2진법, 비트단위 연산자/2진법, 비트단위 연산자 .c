#include<stdio.h>
/*
*	2진법 - 0 , 1
*	char -> 1byte = -128 ~ 127  / nusigned 사용시 => 256
*	L 0000 0001( 맨앞의 숫자는 부호문자이고 부호문자가 0일때 양수를 뜻하고 1이면 음수를 뜻한다.)
*
*	비트단위 연산자 ( &(AND), |(OR), ^(XOR), ~(NOT) )
*	L 비트끼리 연산한다
*
*	예) &(AND) 연산자
*		4-> 0000 0100
*		5-> 0000 0101
*			0000 0100 => 4로 출력
*
*	~(NOT) 1. 비트반전(1의 보수) 바꿔주고 > 2. 1비트 더하기(2의 보수)
*
*	음수이거나 이진법으로 표현시 음수인경우 2의 보수처리 해준다.
*	예) -4  표기 =	4를 0000 0100
*		2의 보수 처리후	1111 1011
*					    0000 0001 1비트를 더한다.
*						1111 1100 => 다시 2의 보수를 해주고 1비트 추가

		-15 표기 = 15를 0000 1111
		2의 보수 처리루 1111 0000
		1비트를 더한다  0000 0001
						1111 0001 => -15
	다시 2의 보수처리  10000 1110
						0000 0001
					   10000 1111 => -15

*
*
*
*/
int main()
{
	int a = 3;	// 0000 0011
	int b = 5;	// 0000 0101
	printf("3 & 5 = %d\n", a & b);	//( AND )  둘다 1이여야 1로 반환 0000 0001
	printf("3 | 5 = %d\n", a | b);	// ( OR )  하나라도 1이 있으면 1로 반환 0000 0111
	printf("3 ^ 5 = %d\n", a ^ b);	//( XOR )  둘이 다르면 1로 반환 0000 0110
	printf("~3 = %d\n", ~b);		//( NOT )  1000 0001(비트 반전후 2의 보수)을 더하여 1000 0100

	int var = -4;
	printf("%d");

	return 0;
}